---
title: "Reactivity"
author: "Gordon Shotwell & Joe Cheng"
title-slide-attributes: 
  data-background-color: black
  data-background-image:  images/toc-people-dark.svg
  data-background-size: contain
format:
  positconfslides-revealjs: 
    incremental: true
    chalkboard: true
    slide-number: c/t
    code-copy: true
    center-title-slide: false
    highlight-style: a11y
    width: "1600"
    height: "900"
    css: "styles.css"
    filters:
      - positconfslides
---
```{python}
# | echo: false
import os

os.chdir("..")
from helpers import problem_tabs, include_shiny_folder, Quiz, multiple_choice_app

```

# Reactivity overview


## How did Shiny do that?

```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/problem-sets/1-getting-started/1.10-add-plot",
    file_name="app-solution.py",
    exclusions=["app.py"],
    components="viewer",
    viewer_height=500,
)
```

## How did Shiny do that?

- We told Shiny _what_ to do
- We didn't tell Shiny _when_ to do it

## How do other frameworks work?

- Streamlit: rerender everything everwhere all the time
- Dash/Panel/Gradio: Define callback functions

## Event driven programming

- You have to do it
- Easy to get wrong
- Hard to tell when you've gotten it wrong

## What's a better way?

::: {.v-center-container}
- Infer the relationships between components 
- Build a computation graph
:::

## Does that really work?

- You're not wrong to find this suspicious
- Magic automatic rendering often goes badly wrong
- For this to work, the inference has to be 100% reliable

## It really works

- We have 10 years of experience with this pattern
- R users have found the bugs and illuminated the edge cases
- Shiny will always infer the correct computation graph

## Outputs and recipes


```{.python code-line-numbers="5,12"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)

def server(input: Inputs, output: Outputs, session: Session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```

## Recipes and inputs

```{.python code-line-numbers="4,13"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)


def server(input: Inputs, output: Outputs, session: Session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```


## Reactive graph

```{mermaid}
flowchart TD
  S[Slider] --> R{Recipe}
  R --> Sc((Text))
```

## Reactive graph

```{mermaid}
flowchart TD
  S[Slider] --> Sc((Text))
```

## Declarative programming

- Tell Shiny what you want to happen
- Trust that the framework will keep everything up-to-date
- You're setting the menu, not doing the cooking

## Event-driven programming
![](images/carmy-yelling.webp)

## Reactive programming
![](images/carmy-whites.png)

## Your turn

Draw the graph of this application

```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/problem-sets/1-getting-started/1.10-add-plot",
    file_name="app-solution.py",
    exclusions=["app.py"],
    components="viewer",
    viewer_height=500,
)
```

## Initial state

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
    Sl[Slider]  --> Sc 
  Sl --> M((Dist Plot))
  linkStyle 0 display:none
  linkStyle 1 display:none
  linkStyle 2 display:none
```

## Calculate Scatter plot

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
    Sl[Slider]  --> Sc 
  Sl --> M((Dist Plot))
  linkStyle 0 display:none
  linkStyle 1 display:none
  linkStyle 2 display:none
  classDef changed fill:#f96
```

## Calculate scatter plot

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
    Sl[Slider]  --> Sc 
  Sl --> M((Dist Plot))
  linkStyle 2 display:none
  classDef changed fill:#f96
```

## Calculate distribution

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
    Sl[Slider]  --> Sc 
  Sl --> M((Dist Plot)):::changed
  linkStyle 2 display:none
  classDef changed fill:#f96
```

## Calculate distribution
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
    Sl[Slider]  --> Sc 
  Sl --> M((Dist Plot)):::changed
  classDef changed fill:#f96
```


## Reactive graph

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
    Sl[Slider]  --> Sc 
  Sl --> M((Dist Plot))
```


## Slider changes

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider]:::changed --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Invalidated

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl[Slider]:::changed --> Sc 
  Sl --> M((Dist Plot)):::changed
  
  classDef changed fill:#f96
```

## Forget dependencies
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 1 display:none
  linkStyle 2 display:none
```

## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 1 display:none
  linkStyle 2 display:none
```

## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
  linkStyle 2 display:none
```


## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot)):::changed
  
  classDef changed fill:#f96
  linkStyle 2 display:none
```

## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot)):::changed
  
  classDef changed fill:#f96
```

## Updated
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Checkbox changes
```{mermaid}
flowchart TD
  C[Checkbox]:::changed --> Sc((Scatter\nPlot))
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Invalidated

```{mermaid}
flowchart TD
  C[Checkbox]:::changed --> Sc((Scatter\nPlot)):::changed
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Forget dependencies
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 1 display:none
```

## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 1 display:none
```

## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Updated
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Reactivity scales

- Every Shiny app uses this pattern
- Works for dynamic UIs
- Shiny is lazy 

## Your turn

TODO: Insert reactivity exercise here

# Reactive calculations

## Handling repetition

- So far we've been working with shallow reactive graphs
- Each input is passed to a rendering function which produces an output
- Input -> Recipe -> Output can produce repetitive, inefficient applications
- `@reactive.Calc` lets you define calculations which are consumed by downstream functions
- This adds intermediary nodes to the reactive graph

## Reactive Calc example

```{python}
# | echo: false
# | output: asis

include_shiny_folder("apps/examples/2.0-simple-reactive-calc")
```

## Identify repition
```{.python code-line-numbers="4,5,11,12"}
    @output
    @render.table
    def df():
        rand = np.random.rand(input.n_rows(), 1)
        df = pd.DataFrame(rand, columns=["col_1"])
        return df

    @output
    @render.plot
    def hist():
        rand = np.random.rand(input.n_rows(), 1)
        df = pd.DataFrame(rand, columns=["col_1"])
        plot = (
            ggplot(df, aes(x="col_1"))
            + geom_histogram(binwidth=0.1, fill="blue", color="black")
            + labs(x="Random Values", y="Frequency", title="Histogram of Random Data")
        )
        return plot
```

## Problems with repetition

1) Code is in multiple places
2) The app is taking the sample twice
3) The table and graph are not using the same sample!

## Reactive Calculation to the rescue
```{.python code-line-numbers="1-4,9,15"}
    @reactive.Cale
    def sampled_df():
        rand = np.random.rand(input.n_rows(), 1)
        df = pd.DataFrame(rand, columns=["col_1"])

    @output
    @render.table
    def df():
        return sampled_df()

    @output
    @render.plot
    def hist():
        plot = (
            ggplot(sampled_df(), aes(x="col_1"))
            + geom_histogram(binwidth=0.1, fill="blue", color="black")
            + labs(x="Random Values", y="Frequency", title="Histogram of Random Data")
        )
        return plot
```

## Reactive calculations
- Defined with the `@reactive.Calc` decorator
- Called like other inputs
- Can consume inputs, reactive values, or other reactive calculations
- Adds a node to the reactive graph.

## Initial state
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 1 display:none
  linkStyle 2 display:none
```

## Calculate table
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]:::changed
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 1 display:none
  linkStyle 2 display:none
```

## Calculate table
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]:::changed
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 2 display:none
```

## Calculate sample
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]:::changed
  S --> T[Table]:::changed
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 2 display:none
```

## Calculate sample
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]:::changed
  S --> T[Table]:::changed
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 2 display:none
```

## Recalculate plot
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]
  S --> P[Plot]:::changed
  
  classDef changed fill:#f96
  linkStyle 2 display:none
```

## Recalculate plot
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]
  S --> P[Plot]:::changed
  
  classDef changed fill:#f96
```

## Deep reactive graph
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]
  S --> P[Plot]
  
  classDef changed fill:#f96
```

## Slider changes

```{mermaid}
flowchart TD
  Sl[Slider]:::changed --> S[Sample]
  S --> T[Table]
  S --> P[Plot]
  
  classDef changed fill:#f96
```

## Invalidated
```{mermaid}
flowchart TD
  Sl[Slider]:::changed --> S[Sample]:::changed
  S --> T[Table]
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 0 display:none
```

## Invalidated
```{mermaid}
flowchart TD
  Sl[Slider]:::changed --> S[Sample]:::changed
  S --> T[Table]:::changed
  S --> P[Plot]:::changed
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 1 display:none
  linkStyle 2 display:none
```

## Recalculate table
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]:::changed
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 1 display:none
  linkStyle 2 display:none
```

## Recalculate table
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]:::changed
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 2 display:none
```

## Recalculate sample
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]:::changed
  S --> T[Table]:::changed
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 0 display:none
  linkStyle 2 display:none
```

## Recalculate sample
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]:::changed
  S --> T[Table]:::changed
  S --> P[Plot]
  
  classDef changed fill:#f96
  linkStyle 2 display:none
```

## Recalculate plot
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]
  S --> P[Plot]:::changed
  
  classDef changed fill:#f96
  linkStyle 2 display:none
```

## Recalculate plot
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]
  S --> P[Plot]:::changed
  
  classDef changed fill:#f96
```

## Updated
```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S --> T[Table]
  S --> P[Plot]
  classDef changed fill:#f96
```


## Your turn

Go to [exercises/5-reactivity](../exercises/5-reactivity.html) or run `apps/problem-sets/exercises/5-reactivity` locally.


## Exercise 2.2 answer 

```{mermaid}
flowchart TD
  Sl[Slider] --> S[Sample]
  S[Sample] --> F[Filter]
  F --> T((Table))
  S --> P((Plot))
  F --> Tx((Text))
  classDef changed fill:#f96
```

## Escaping reactivity

- By default any change in a shiny input will trigger a recalculation
- This isn't always the user interaction you want
    - Database queries
    - Expensive modeling
    - Grouping multiple filters together
    - Side effects
- `reactive.event` and `reactive.Effect` allow you to interrupt reactive calculations.

## Example
```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/problem-sets/2-reactivity/2.3-reactive-event",
    file_name="app.py",
    exclusions=["app-solution.py"],
    components="viewer",
    viewer_height=500,
)
```

## reactive.event
```{.python}
@output
@render.text
@reactive.event(input.my_input)
def txt():
  return "Here is my text"
```

- Reactive event is an explicit way to create a reactive link
- It can be used in conjunction with rendering functions, `reactive.Calc` and `reactive.Effect`
- It tells shiny to invalidate the node whenever or or more inputs change
- `reactive.event` is often used with action buttons or action links

## Your turn

Go to [exercises/6-reactive-event](../exercises/6-reactive-event.html) or run `apps/problem-sets/2-reactivity/2.3-reactive-event` locally.


# Side effects

## What we've learned
- How Shiny rerenders elements 
- How Shiny detects dependencies between elements (renderers and inputs)
- How to add depth to the reactive graph with `reactive.Calc`
- How to explicitly specify dependencies with `reactive.event`


## Is that enough?
- Shiny has a function `ui.show_modal` which triggers a modal window. 
- Using what you know so far, how would you call this function?

```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/examples/3.0-modal",
    components="viewer",
    viewer_height=500,
)
```

## Reactivity is for values
- Normal reactive elements pass values 
- A node is invalidated when the last value it received is out of date
- Rendering functions and `reactive.Calc` all expect a return value
- We often don't care about values
- When the user clicks a button we care about the fact that they clicked it

## Reactive Effects
- The `@reactive.Effect` decorator allows you to react to an input without returning a value
- Usually paird with `@reactive.event` 

``` {.python}
@reactive.Effect
2@reactive.event(input.show)
def toggle_modal():
    m = ui.modal(
        "This is a somewhat important message.",
        title="Click outside the modal to close",
        easy_close=True,
        footer=None,
    )
    ui.modal_show(m)
```

## The rule

### Use `reactive.Calc` or `render.*` when you want a **value** use `@reactive.Effect` when you want a **side effect**

## What's a side effect?
```{python}
# | echo: false
# | output: asis

from helpers import multiple_choice_app, Quiz

questions = Quiz(
    {
        "Writing a CSV": {
            "choices": ["value", "side effect"],
            "answer": "side effect",
        },
        "Querying a database": {
            "choices": ["value", "side effect"],
            "answer": "value",
        },
        "Adding two numbers": {
            "choices": ["value", "side effect"],
            "answer": "value",
        },
        "A function which prints to the console": {
            "choices": ["value", "side effect"],
            "answer": "side effect",
        },
        "Fetching the current temperature from an API": {
            "choices": ["value", "side effect"],
            "answer": "value",
        },
        "A function which sorts a list in place": {
            "choices": ["value", "side effect"],
            "answer": "side effect",
        },
        "Getting a model score for a set of inputs": {
            "choices": ["value", "side effect"],
            "answer": "value",
        },
        "Deploying a model to a hosting service": {
            "choices": ["value", "side effect"],
            "answer": "side effect",
        },
    }
)

multiple_choice_app(questions)
```

## What's a side effect?

- Somewhat context dependent
- Multiple strategies can work
- If your solution feels complicated and painful, ask whether you should use the other strategy

## Your turn

Go to [exercises/7-reactivity](../exercises/7-reactivity.html) or run `apps/problem-sets/3-reactive-effects/3.1-update-slider` locally.
